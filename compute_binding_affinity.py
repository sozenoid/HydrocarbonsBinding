################
################
################
################
####
#### This piece of code is meant to compute the binding affinity of a single of a molecule with CB[7] 
#### PRE: A sdf file containing the best n pose of the molecule with CB[7] is given as generated by autodock vina, converted back to sdf by open babel (2.4.1)
####      The binding affinity computed AMBER from AmberTools. The complex are generated again by combining the CB_candidate.pdbqt coordinates with the coordinates of the molecule poses
####	  
####
#### POST: The binding affinity for all the poses are computed and the added to an output log file
################
################
################
################



class guestMolecule:
	def __init__(self, SDFblock):
		"""
		PRE : SDFblock is a valid sdf file containing n conformations for the same guest molecule (usually 9 or less). The rdkit module should be available
		POST : an object guestMolecule is created that contains 
		"""
		self.workpath = "/home/macenrola/Desktop/"
		self.baseConf = [x for x in Chem.SDMolSupplier(SDFblock)]
		self.dockedConf = self.get_docked_conformations(self.baseConf)
		self.produce_formatted_PDBs(self.baseConf, self.dockedConf)

	def get_docked_conformations(self, listOfMols):
		"""
		PRE: Takes in a list of valid rdkit mol formats
		POST: Returns another list of those molecules merged with the pdb coordinates of CB[7]
		"""
		dockedConfs = []
		CB_host = Chem.MolFromPDBFile("/home/macenrola/Thesis/ScreeningManuscriptFinalData/HydrocarbonsBindingPython/CB_candidate_data/CB_candidate.pdb")
		for mol in listOfMols:
			dockedConfs.append(Chem.CombineMols(mol, CB_host))
		self.write_mol_to_pdb(CB_host, fout="{}CB_candidate_formatted.pdb".format(self.workpath),  residueName=('CB7', 'GST'), residueNumber=(2,1) )
		return dockedConfs

	def get_sphere_circle(self, listOfDockedMols):
		"""
		PRE: Takes in a list of complexes
		POST: Returns their enclosing sphere diameter
		"""
		pass

	def produce_formatted_PDBs(self, listOfMols, listOfDockedMols):
		"""
		PRE: Takes in rdkit mols of guests and their docked versions
		PST: Produces one valid pdb file for each molecule and docked complex 
		"""
		for lst in zip(["guests", "complex"],[listOfMols, listOfDockedMols]):
			for i,mol in enumerate(lst[1]):
				self.write_mol_to_pdb(mol, fout="{}{}Pose{}.pdb".format(self.workpath, lst[0], i))

	def remove_CONNECT_LINES(self, fname):
		"""
		PRE: fname contains a valid PDB file of a molecule with 3D coordinates, MOLECULES NEED TO BE NAMED
		POST: The lines containing CONNECT and MASTER are removed from the original file, the original file IS MODIFIED
		"""
		with open(fname, 'rb') as r:
			lines = r.readlines()
		with open(fname, 'wb') as w:
			w.writelines([x for x in lines if 'CONECT' not in x if 'MASTER' not in x][1:])


	def write_mol_to_pdb(self, molin, fout, converge=False, residueName=('GST', 'CB7'), residueNumber=(1,2)):
		"""
		PRE : Takes in the absolute path to a SDF file, if a single molecule is converted only the first element of both residueName and residueNumber is used, both in the case of a complex
		POST: Produces a PDB file by converting the original molecule from the SDF file, DOES NOT optimize the conformation by default
		"""
		mol = molin
		flavour = 28
		if converge:
			converge_molecule(mol)
		
		isComplex = (len(Chem.GetMolFrags(mol)) != 1)  

		print '{} contains {} Fragments'.format("current mol", len(Chem.GetMolFrags(mol)))

		if not isComplex:
			atm_dic = {}
			for atom in mol.GetAtoms():
				if atom.GetSymbol() not in atm_dic:
					atm_dic[atom.GetSymbol()] = 1
				else: atm_dic[atom.GetSymbol()] += 1

				atom.SetMonomerInfo(Chem.rdchem.AtomPDBResidueInfo('{} {}'.format(atom.GetSymbol()+str(atm_dic[atom.GetSymbol()])+' '*int(atm_dic[atom.GetSymbol()]<10), residueName[0])))
				atom.GetMonomerInfo().SetResidueNumber(residueNumber[0])
			Chem.MolToPDBFile(mol, fout, flavor=flavour)
			self.fix_PDB_spacing(fout, hostname=residueName[1])
			return
		else:
			comp = Chem.GetMolFrags(mol, asMols=True)
			if comp[0].GetNumAtoms() < comp[1].GetNumAtoms(): guest,host = comp[0], comp[1]
			else: guest,host = comp[1], comp[0]
			for res in zip((guest, host),[0,1]):
				atm_dic = {}
				for atom in res[0].GetAtoms():
					if atom.GetSymbol() not in atm_dic:
						atm_dic[atom.GetSymbol()] = 1
					else: atm_dic[atom.GetSymbol()] += 1

					atom.SetMonomerInfo(Chem.rdchem.AtomPDBResidueInfo('{} {}'.format(atom.GetSymbol()+str(atm_dic[atom.GetSymbol()])+' '*int(atm_dic[atom.GetSymbol()]<10), residueName[res[1]])))
					atom.GetMonomerInfo().SetResidueNumber(residueNumber[res[1]])

			comp_annotated = Chem.CombineMols(guest, host)
			comp_annotated.SetProp('_Name', mol.GetProp('_Name'))
			Chem.MolToPDBFile(comp_annotated, fout, flavor=flavour)
			self.remove_CONNECT_LINES(fout)
			self.fix_PDB_spacing(fout, hostname=residueName[1])

	def fix_PDB_spacing(self, fname, hostname = 'CB7', strandname = 'A'):
		"""
		PRE: The PDB files is formated by rdkit MolToPDBFile flavour 28 without any MASTER, TER, CONECT or Charge flags, 
		POST: The file IS MODIFIED to be formated with the adequate amount of blank space to be read by AMBER, This method destroys the original file
		"""
		raw_spc = [7, 2, 4, 4, 4, 12, 8, 8, 6, 6, 12, 0]
		new_lines = []
		cb_yet = False
		with open(fname, 'rb') as r:
			for line in r:
				if hostname in line and not cb_yet:
					cb_yet = True
					new_lines.append('TER')
					strandname = 'B'
				if 'ATOM' in line:
					line_content = line.split()
					line_content.insert(4, strandname)
					# print line_content
					ls = [len(x) for x in line_content]
					actual_spacing = [raw_spc[0]-ls[1], # after ATOM 
					raw_spc[1],  # after ATOM# (11)
					raw_spc[2]-ls[2], # after ATOM NAME (H41)
					raw_spc[3]-ls[3], # after RESIDUE NAME (CUC)
					raw_spc[4]-ls[4], # after CHAIN ID (A)
					raw_spc[5]-ls[6], # after RESIDUE NUMBER (1)
					raw_spc[6]-ls[7], # after X CART COORDINATE (6.171)
					raw_spc[7]-ls[8], # after Y CART COORDINATE (3.377)
					raw_spc[8]-ls[9], # after Z CART COORDINATE (21.096)
					raw_spc[9]-ls[10], # after enigmatic number (1.00)
					raw_spc[10]-ls[11], # after partial charge (0.00)
					raw_spc[11], # after ATOMIC SYMBOL (N)
					]
					new_lines.append(''.join([x[0]+' '*x[1] for x in zip(line_content, actual_spacing)]))
					#print new_lines[-1]

				else:
					new_lines.append(line.strip())
					#print new_lines[-1]
		with open(fname, 'wb') as w:
			w.writelines('\n'.join(new_lines)+'\n')



if __name__ == "__main__":
	import rdkit 
	from rdkit import Chem
	from rdkit.Chem import AllChem
	testGuest = guestMolecule("/home/macenrola/Thesis/ScreeningManuscriptFinalData/HydrocarbonsBindingPython/tests/129891208xzzgnsu_OUT_GUEST27.sdf.pdbqt-ALL.pdbqt.sdf")
	for i, m in enumerate(testGuest.dockedConf):
		print Chem.MolToMolFile(m, "/home/macenrola/Desktop/testPose{}.sdf".format(i))